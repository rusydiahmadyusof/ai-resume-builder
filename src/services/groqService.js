import Groq from 'groq-sdk'

const groq = new Groq({
  apiKey: import.meta.env.VITE_GROQ_API_KEY,
  dangerouslyAllowBrowser: true, // Required for browser usage
})

export const groqService = {
  /**
   * Generate tailored resume content using Groq API
   * @param {Object} personalData - User's personal information
   * @param {Object} jobData - Job application details
   * @returns {Promise<Object>} Generated resume content
   */
  generateResumeContent: async (personalData, jobData) => {
    try {
      if (!import.meta.env.VITE_GROQ_API_KEY) {
        throw new Error('Groq API key is not configured. Please add VITE_GROQ_API_KEY to your .env file.')
      }

      const prompt = createPrompt(personalData, jobData)

      const completion = await groq.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: `You are an expert resume writer and career counselor. Your task is to create a professional, tailored resume that highlights the candidate's experience and skills relevant to the job they're applying for. Focus on:
1. Creating a compelling professional summary
2. Rewriting work experience descriptions to match job requirements
3. Highlighting relevant skills and achievements
4. Using industry-standard keywords
5. Quantifying achievements where possible
6. Making the resume ATS-friendly

Return the response as a JSON object with the following structure:
{
  "summary": "tailored professional summary",
  "workExperience": [
    {
      "company": "company name",
      "position": "position title",
      "startDate": "start date",
      "endDate": "end date or 'Present'",
      "responsibilities": "tailored responsibilities and achievements"
    }
  ],
  "skills": ["relevant skill 1", "relevant skill 2", ...]
}`,
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        model: 'llama-3.3-70b-versatile',
        temperature: 0.7,
        max_tokens: 2000,
      })

      const content = completion.choices[0]?.message?.content || ''
      
      // Try to parse JSON from the response
      let generatedContent
      try {
        // Extract JSON from markdown code blocks if present
        const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || content.match(/```\n([\s\S]*?)\n```/)
        const jsonString = jsonMatch ? jsonMatch[1] : content
        generatedContent = JSON.parse(jsonString)
      } catch (parseError) {
        // If JSON parsing fails, create a fallback structure
        console.warn('Failed to parse AI response as JSON, using fallback:', parseError)
        generatedContent = {
          summary: content.split('\n')[0] || 'Professional summary generated by AI',
          workExperience: personalData.workExperience || [],
          skills: personalData.skills || [],
        }
      }

      return {
        success: true,
        data: generatedContent,
      }
    } catch (error) {
      console.error('Error generating resume content:', error)
      return {
        success: false,
        error: error.message || 'Failed to generate resume content',
      }
    }
  },

  /**
   * Generate only the professional summary
   */
  generateSummary: async (personalData, jobData) => {
    try {
      const prompt = `Create a compelling professional summary (2-3 sentences) for a resume based on:
      
Personal Information:
- Name: ${personalData.name || 'Candidate'}
- Experience: ${personalData.workExperience?.length || 0} position(s)
- Skills: ${personalData.skills?.join(', ') || 'Various skills'}

Job Application:
- Title: ${jobData.jobTitle || 'Position'}
- Description: ${jobData.jobDescription?.substring(0, 500) || 'Not provided'}

Make it concise, impactful, and tailored to the job requirements.`

      const completion = await groq.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: 'You are an expert resume writer. Create professional, concise summaries.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        model: 'llama-3.3-70b-versatile',
        temperature: 0.7,
        max_tokens: 200,
      })

      return {
        success: true,
        summary: completion.choices[0]?.message?.content || '',
      }
    } catch (error) {
      console.error('Error generating summary:', error)
      return {
        success: false,
        error: error.message || 'Failed to generate summary',
      }
    }
  },

  /**
   * Extract personal information from resume PDF text using AI
   * @param {string} pdfText - Extracted text from PDF
   * @returns {Promise<Object>} Extracted personal information
   */
  extractPersonalInfoFromPDF: async (pdfText) => {
    try {
      if (!import.meta.env.VITE_GROQ_API_KEY) {
        throw new Error('Groq API key is not configured.')
      }

      // Limit text to avoid token limits
      const limitedText = pdfText.substring(0, 3000)

      const prompt = `Extract personal information from the following resume text. Return ONLY a valid JSON object with this exact structure:

{
  "name": "full name or empty string",
  "email": "email address or empty string",
  "phone": "phone number or empty string",
  "address": "address or empty string",
  "linkedin": "LinkedIn URL or empty string",
  "github": "GitHub URL or empty string",
  "portfolio": "portfolio website URL or empty string",
  "summary": "professional summary or empty string"
}

Resume text:
${limitedText}

Important:
- Extract only the information that is clearly present in the text
- If a field is not found, return an empty string for that field
- For email, phone, and URLs, extract the exact values
- For summary, extract the professional summary/objective section if available
- Return ONLY valid JSON, no additional text or explanation`

      const completion = await groq.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: 'You are an expert at extracting structured data from resume text. Always return valid JSON only, no additional text.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        model: 'llama-3.3-70b-versatile',
        temperature: 0.3, // Lower temperature for more accurate extraction
        max_tokens: 500,
      })

      const content = completion.choices[0]?.message?.content || ''
      
      console.log('AI response content:', content)
      
      // Extract JSON from response
      let extractedData
      try {
        // Try to find JSON in the response
        let jsonString = content.trim()
        
        // Remove markdown code blocks if present
        jsonString = jsonString.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim()
        
        // Try to extract JSON object
        const jsonMatch = jsonString.match(/\{[\s\S]*\}/)
        if (jsonMatch) {
          jsonString = jsonMatch[0]
        }
        
        extractedData = JSON.parse(jsonString)
        
        // Validate and clean extracted data
        extractedData = {
          name: (extractedData.name || '').trim(),
          email: (extractedData.email || '').trim(),
          phone: (extractedData.phone || '').trim(),
          address: (extractedData.address || '').trim(),
          linkedin: (extractedData.linkedin || '').trim(),
          github: (extractedData.github || '').trim(),
          portfolio: (extractedData.portfolio || '').trim(),
          summary: (extractedData.summary || '').trim(),
        }
        
        console.log('Parsed extracted data:', extractedData)
      } catch (parseError) {
        console.warn('Failed to parse AI response as JSON, using fallback:', parseError, 'Content:', content)
        // Fallback: try basic regex extraction
        extractedData = {
          name: extractField(pdfText, 'name'),
          email: extractEmail(pdfText),
          phone: extractPhone(pdfText),
          address: '',
          linkedin: extractLinkedIn(pdfText),
          github: extractGitHub(pdfText),
          portfolio: '',
          summary: '',
        }
        console.log('Fallback extracted data:', extractedData)
      }

      return {
        success: true,
        data: extractedData,
      }
    } catch (error) {
      console.error('Error extracting personal info from PDF:', error)
      return {
        success: false,
        error: error.message || 'Failed to extract information from PDF',
      }
    }
  },

  /**
   * Extract job information from HTML content using AI
   * @param {string} html - HTML content from job posting page
   * @returns {Promise<Object>} Extracted job information
   */
  extractJobInfoFromHTML: async (html) => {
    try {
      if (!import.meta.env.VITE_GROQ_API_KEY) {
        throw new Error('Groq API key is not configured.')
      }

      // Limit HTML size to avoid token limits
      const limitedHTML = html.length > 8000 ? html.substring(0, 8000) + '...' : html

      const prompt = `Extract job information from the following HTML content of a job posting page. Return ONLY a valid JSON object with this exact structure:

{
  "jobTitle": "job title or empty string",
  "jobDescription": "full job description or empty string"
}

HTML content:
${limitedHTML}

Important:
- Extract the job title from headings (h1, h2), meta tags, or title elements
- Extract the complete job description from the main content area
- Remove HTML tags from the extracted text
- If a field is not found, return an empty string for that field
- For job description, include all relevant details: requirements, responsibilities, qualifications, etc.
- Return ONLY valid JSON, no additional text or explanation`

      const completion = await groq.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: 'You are an expert at extracting structured data from job posting HTML. Always return valid JSON only, no additional text. Extract job title and full job description accurately.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        model: 'llama-3.3-70b-versatile',
        temperature: 0.3, // Lower temperature for more accurate extraction
        max_tokens: 1500,
      })

      const content = completion.choices[0]?.message?.content || ''
      
      // Extract JSON from response
      let extractedData
      try {
        const jsonMatch = content.match(/```json\n([\s\S]*?)\n```/) || 
                         content.match(/```\n([\s\S]*?)\n```/) ||
                         content.match(/\{[\s\S]*\}/)
        const jsonString = jsonMatch ? (jsonMatch[1] || jsonMatch[0]) : content
        extractedData = JSON.parse(jsonString)
      } catch (parseError) {
        console.warn('Failed to parse AI response as JSON, using fallback:', parseError)
        // Fallback: try basic regex extraction
        extractedData = {
          jobTitle: extractJobTitleFromHTML(html),
          jobDescription: extractJobDescriptionFromHTML(html),
        }
      }

      // Validate extracted data
      if (!extractedData.jobTitle && !extractedData.jobDescription) {
        return {
          success: false,
          error: 'Could not extract job information. The page may not be a valid job posting or the content is not accessible.',
        }
      }

      return {
        success: true,
        data: extractedData,
      }
    } catch (error) {
      console.error('Error extracting job info from HTML:', error)
      return {
        success: false,
        error: error.message || 'Failed to extract job information',
      }
    }
  },

  /**
   * Generate cover letter using Groq API
   * @param {Object} personalData - User's personal information
   * @param {Object} jobData - Job application details
   * @param {Object} options - Cover letter options (tone, length, style)
   * @returns {Promise<Object>} Generated cover letter
   */
  generateCoverLetter: async (personalData, jobData, options = {}) => {
    try {
      if (!import.meta.env.VITE_GROQ_API_KEY) {
        throw new Error('Groq API key is not configured.')
      }

      const {
        tone = 'professional', // professional, friendly, formal, enthusiastic
        length = 'medium', // short, medium, long
        style = 'standard', // standard, narrative, bullet-points
      } = options

      const toneInstructions = {
        professional: 'Use a professional, confident tone',
        friendly: 'Use a warm, approachable tone while remaining professional',
        formal: 'Use a formal, traditional business tone',
        enthusiastic: 'Use an enthusiastic, energetic tone that shows passion',
      }

      const lengthGuidelines = {
        short: 'Keep it concise (200-300 words, 3-4 paragraphs)',
        medium: 'Use moderate length (300-500 words, 4-5 paragraphs)',
        long: 'Provide comprehensive detail (500-700 words, 5-6 paragraphs)',
      }

      const styleInstructions = {
        standard: 'Write in standard paragraph format',
        narrative: 'Tell a compelling story about your career journey',
        'bullet-points': 'Use bullet points to highlight key achievements',
      }

      const prompt = `Write a compelling cover letter for the following candidate applying to this position.

CANDIDATE INFORMATION:
Name: ${personalData.name || 'Not provided'}
Email: ${personalData.email || 'Not provided'}
Phone: ${personalData.phone || 'Not provided'}

Professional Summary:
${personalData.summary || 'No summary provided'}

Work Experience:
${formatWorkExperience(personalData.workExperience)}

Education:
${formatEducation(personalData.education)}

Skills: ${personalData.skills?.join(', ') || 'Not provided'}

Certifications:
${formatCertifications(personalData.certifications)}

JOB APPLICATION:
Job Title: ${jobData.jobTitle || 'Not specified'}

Job Description:
${jobData.jobDescription || 'No job description provided'}

INSTRUCTIONS:
1. ${toneInstructions[tone]}
2. ${lengthGuidelines[length]}
3. ${styleInstructions[style]}
4. Address the hiring manager professionally (use "Dear Hiring Manager" if name not provided)
5. Start with a strong opening that captures attention
6. Explain why you're interested in this specific position and company
7. Highlight 2-3 key achievements or experiences that match the job requirements
8. Show knowledge of the company/role if possible
9. End with a confident closing that invites further discussion
10. Include a professional closing (Sincerely, Best regards, etc.)
11. Make it personal and tailored to this specific job - avoid generic phrases
12. Use keywords from the job description naturally
13. Quantify achievements where possible

Return ONLY the cover letter text, no additional explanations or formatting. Start directly with the greeting.`

      const completion = await groq.chat.completions.create({
        messages: [
          {
            role: 'system',
            content: `You are an expert cover letter writer and career counselor. Your task is to create a compelling, personalized cover letter that:
- Stands out to hiring managers
- Clearly demonstrates why the candidate is a perfect fit
- Shows genuine interest in the position
- Uses the right tone and length as specified
- Incorporates keywords naturally
- Tells a compelling story

Always return only the cover letter text, properly formatted with paragraphs.`,
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        model: 'llama-3.3-70b-versatile',
        temperature: 0.8, // Higher for more creative writing
        max_tokens: 1500,
      })

      const coverLetter = completion.choices[0]?.message?.content || ''

      if (!coverLetter.trim()) {
        return {
          success: false,
          error: 'Failed to generate cover letter. Please try again.',
        }
      }

      return {
        success: true,
        data: {
          coverLetter: coverLetter.trim(),
          metadata: {
            tone,
            length,
            style,
            wordCount: coverLetter.split(/\s+/).length,
            generatedAt: new Date().toISOString(),
          },
        },
      }
    } catch (error) {
      console.error('Error generating cover letter:', error)
      return {
        success: false,
        error: error.message || 'Failed to generate cover letter',
      }
    }
  },
}

/**
 * Create a comprehensive prompt for resume generation
 */
function createPrompt(personalData, jobData) {
  return `Create a tailored resume for the following candidate applying to this position:

CANDIDATE INFORMATION:
Name: ${personalData.name || 'Not provided'}
Email: ${personalData.email || 'Not provided'}
Phone: ${personalData.phone || 'Not provided'}

Professional Summary:
${personalData.summary || 'No summary provided'}

Work Experience:
${formatWorkExperience(personalData.workExperience)}

Education:
${formatEducation(personalData.education)}

Skills: ${personalData.skills?.join(', ') || 'Not provided'}

Certifications:
${formatCertifications(personalData.certifications)}

Languages: ${formatLanguages(personalData.languages)}

JOB APPLICATION:
Job Title: ${jobData.jobTitle || 'Not specified'}

Job Description:
${jobData.jobDescription || 'No job description provided'}

INSTRUCTIONS:
1. Create an optimized professional summary (2-3 sentences) that highlights relevant experience for this specific job
2. Rewrite each work experience entry to emphasize achievements and responsibilities that match the job requirements
3. Use action verbs and quantify achievements where possible
4. Highlight skills that are most relevant to the job
5. Use keywords from the job description naturally
6. Make the resume ATS-friendly and professional
7. Ensure all dates and company names are preserved exactly as provided

Return ONLY a valid JSON object with the structure specified in the system message.`
}

function formatWorkExperience(experiences) {
  if (!experiences || experiences.length === 0) {
    return 'No work experience provided'
  }
  return experiences
    .map(
      (exp, index) => `
${index + 1}. ${exp.position || 'Position'} at ${exp.company || 'Company'}
   Period: ${exp.startDate || 'Start'} - ${exp.current ? 'Present' : exp.endDate || 'End'}
   Responsibilities: ${exp.responsibilities || 'Not provided'}`
    )
    .join('\n')
}

function formatEducation(education) {
  if (!education || education.length === 0) {
    return 'No education provided'
  }
  return education
    .map(
      (edu, index) => `
${index + 1}. ${edu.degree || 'Degree'} in ${edu.field || 'Field'} from ${edu.institution || 'Institution'}
   Period: ${edu.startDate || 'Start'} - ${edu.current ? 'Present' : edu.endDate || 'End'}`
    )
    .join('\n')
}

function formatCertifications(certifications) {
  if (!certifications || certifications.length === 0) {
    return 'No certifications provided'
  }
  return certifications
    .map((cert) => `- ${cert.name || 'Certification'} from ${cert.issuer || 'Issuer'} (${cert.date || 'Date'})`)
    .join('\n')
}

function formatLanguages(languages) {
  if (!languages || languages.length === 0) {
    return 'No languages provided'
  }
  return languages.map((lang) => `${lang.name || 'Language'} (${lang.proficiency || 'Proficiency'})`).join(', ')
}

// Helper functions for fallback extraction
function extractEmail(text) {
  const emailRegex = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/
  const match = text.match(emailRegex)
  return match ? match[0] : ''
}

function extractPhone(text) {
  const phoneRegex = /(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}/
  const match = text.match(phoneRegex)
  return match ? match[0] : ''
}

function extractLinkedIn(text) {
  const linkedInRegex = /(https?:\/\/)?(www\.)?linkedin\.com\/in\/[\w-]+/i
  const match = text.match(linkedInRegex)
  return match ? match[0] : ''
}

function extractGitHub(text) {
  const githubRegex = /(https?:\/\/)?(www\.)?github\.com\/[\w-]+/i
  const match = text.match(githubRegex)
  return match ? match[0] : ''
}

function extractField(text, fieldName) {
  // Simple extraction - look for common patterns
  const lines = text.split('\n').slice(0, 5) // First 5 lines usually contain name
  return lines[0]?.trim() || ''
}

// Helper functions for fallback job extraction
function extractJobTitleFromHTML(html) {
  // Try to find job title in common patterns
  const titleMatch = html.match(/<h1[^>]*>([^<]+)<\/h1>/i) ||
                    html.match(/<title>([^<]+)<\/title>/i) ||
                    html.match(/<meta[^>]*property=["']og:title["'][^>]*content=["']([^"']+)["']/i) ||
                    html.match(/<h2[^>]*>([^<]+)<\/h2>/i)
  
  if (titleMatch) {
    return titleMatch[1].trim().replace(/&[^;]+;/g, '')
  }
  
  // Try meta description
  const metaMatch = html.match(/<meta[^>]*name=["']title["'][^>]*content=["']([^"']+)["']/i)
  if (metaMatch) {
    return metaMatch[1].trim()
  }
  
  return ''
}

function extractJobDescriptionFromHTML(html) {
  // Try to find job description in common content areas
  // Look for divs/sections with common job description classes
  const descriptionPatterns = [
    /<div[^>]*class=["'][^"']*job-description[^"']*["'][^>]*>([\s\S]*?)<\/div>/i,
    /<div[^>]*class=["'][^"']*description[^"']*["'][^>]*>([\s\S]*?)<\/div>/i,
    /<section[^>]*class=["'][^"']*job-details[^"']*["'][^>]*>([\s\S]*?)<\/section>/i,
    /<article[^>]*>([\s\S]{500,})<\/article>/i,
  ]
  
  for (const pattern of descriptionPatterns) {
    const match = html.match(pattern)
    if (match && match[1]) {
      // Remove HTML tags and clean up
      let text = match[1]
        .replace(/<[^>]+>/g, ' ')
        .replace(/&[^;]+;/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
      
      if (text.length > 100) {
        return text.substring(0, 2000) // Limit length
      }
    }
  }
  
  return ''
}

